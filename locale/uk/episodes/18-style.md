---
title: Стиль програмування
teaching: 15
exercises: 15
---

::::::::::::::::::::::::::::::::::::::: objectives

- Забезпечити звукові виправдання основних правил стилю програмування.
- Фактор програм односторінкових сторінок, щоб зробити їх більш читабельними та виправдати зміни.
- Використовувати стандарти кодування спільноти Python (PEP-8).

::::::::::::::::::::::::::::::::::::::::::::::::::

::::::::::::::::::::::::::::::::::::::::::::: питань

- Як я можу зробити програми більш розбірливими?
- Як більшість програмістів форматують свій код?
- Як можуть програми перевірити власну операцію?

::::::::::::::::::::::::::::::::::::::::::::::::::

## Coding style

Відповідний стиль кодування допомагає іншим (у тому числі нашим майбутнім предмам) читати та розуміти код простіше. Код читається набагато частіше, ніж написано, і як [Zen для Python](https://www.python.org/dev/peps/pep-0020) ст., "Кількість читань".
Python запропонував стандартний стиль через один з своїх перших пропозицій підвищення Python (PEP), [PEP8](https://www.python.org/dev/peps/pep-0008).

Варто виділити деякі бали:

- документуйте ваш код і переконайтеся, що припущення, внутрішні алгоритми, очікувані введення, дані тощо, є зрозумілим
- використовувати чіткі, семантично значущі імена змінних
- використовувати пробіл, _not_ для ліній відступу (вкладки можуть викликати проблеми різних текстових редакторів, операційних систем і систем контролю версій)

## Виконайте стандартний стиль Python в коді.

- [PEP8](https\://www\.python. rg/dev/peps/pep-0008):
  – керівництво зі стилів для Python, яке обговорює такі теми, як імені змінних,
  як подавати відступ своєму коду,
  як структурувати дані `import`,
  і т. д.
  Відповідно до PEP8 полегшує читання та розуміння коду інших Python розробників, і щоб зрозуміти, як мають виглядати їх внески.
- Щоб перевірити свій код для відповідності PEP8, ви можете використовувати [програму стилю pycode](https://pypi.org/project/pycodestyle/) та інструменти, такі як [формат чорного коду](https\://github. om/psf/black) може автоматично форматувати ваш код, щоб відповідати PEP8 та pycodestyle (формат блокнотів Jupyter також існує [nb_black](https://github.com/dnanhkhoa/nb_black)).
- Деякі групи та організації дотримуються різних принципів стилю, окрім PEP8. Наприклад, [Google style Guide для Python](https://google.github.io/styleguide/pyguide.html) висловлює дещо різні рекомендації. Google написав програму, яка може допомогти відформатувати код або PEP8 називається [yapf](https://github.com/google/yapf/).
- Що стосується стилю кодування, то ключ - _відповідність_. Виберіть стиль для вашого проекту PEP8, стиль Google, або щось інше і робіть все, щоб ви і всі інші, що працюєте з паличками для цього. Послідовність у проекті часто більш впливає, ніж цей певний стиль. Сумісний стиль зробить ваше програмне забезпечення простішим для читання та розуміння для інших та вашого майбутнього себе.

## Використовувати твердження для перевірки внутрішніх помилок.

Призначення — це простий, але потужний метод, який дозволяє переконатися, що контекст, в якому виконується ваш код, як ви очікуєте.

```python
def calc_bulk_density(mass, volume):
    '''Return dry bulk density = powder mass / powder volume.'''
    assert volume > 0
    return mass / volume
```

Якщо твердження "False", інтерпретер Python викликає виняток "AssertionError\` runtime excepation. Вихідний код виразу, який не вдається, буде відображатися як частина повідомлення про помилку. Щоб ігнорувати твердження у вашому коді запустіть інтерпретер з ключем '-O' (оптимізація). Призначення повинні містити лише прості перевірки і ніколи не змінювати стан програми. Наприклад, твердження ніколи не повинно містити призначення.

## Використовуйте док-струни, щоб надати вбудовану допомогу.

Якщо першим ділом у функції є рядок символів, який не присвоєний безпосередньо змінній, Python прикріплює його до функції, доступної через функцію довідки конструктонів. Цей рядок, що забезпечує документацію, також відомий як _docstring_.

```python
середні значення def (значень):
    "Середнє значення або N0, якщо немає ніяких значень.

    якщо len(values) == 0:
        return None
    return sum(значень) / len(значень)

за допомогою (середня)
```

```output
Help on function average in module __main__:

average(values)
    Return average of values, or None if no values are supplied.
```

:::::::::::::::::::::::::::::::::::::::::  callout

## Багаторядкові рядки

Часто використовувати _багаторядкові рядки_ для документації.
Вони починаються і закінчуються трьома символами лапок (одинарними або подвійними)
та закінчуються трьома відповідними символами.

```python
"""This string spans
multiple lines.

Blank lines are allowed."""
```

::::::::::::::::::::::::::::::::::::::::::::::::::

:::::::::::::::::::::::::::::::::::::::::::: виклик

## Що буде коштувати?

Виділіть рядки в коді нижче, які будуть доступні як он-лайн допомога.
Чи мають бути доступні, але чи не так?
Чи призведе всі рядки до синтаксичної помилки або помилки під час роботи?

```python
"Find maximum edit distance between multiple sequences."
# This finds the maximum distance between all sequences.

def overall_max(sequences):
    '''Determine overall maximum edit distance.'''

    highest = 0
    for left in sequences:
        for right in sequences:
            '''Avoid checking sequence against itself.'''
            if left != right:
                this = edit_distance(left, right)
                highest = max(highest, this)

    # Report.
    return highest
```

::::::::::::::::::::::::::::::::::::::::::::::::::

:::::::::::::::::::::::::::::::::::::::::::: виклик

## Документ Це

Використовуйте коментарі, щоб описати і допомогти іншим зрозуміти потенційно неінтуїтивні
розділи або окремі рядки коду. They are especially useful to whoever
may need to understand and edit your code in the future, including yourself.

Використовуйте docstrings для документування прийнятних входів і очікуються виходи методу
або класу, його призначення, припущення і призначені для поведінки. Docstrings are displayed
when a user invokes the builtin `help` method on your method or class.

Turn the comment in the following function into a docstring
and check that `help` displays it properly.

```python
def middle(a, b, c):
    # повернути середнє значення в 3.
    # Припустимі, значення можна порівнювати.
    values = [a, b, c]
    values.sort()
    повертають значення[1]
```

:::::::::::::::::::: Рішення

## Розв'язок

```python
def middle(a, b, c):
    ''Повертає середнє значення в 3.
    Припустимі, які значення дійсно можна порівняти. ''
    values = [a, b, c]
    значень. ort()
    повертає значення[1]
```

:::::::::::::::::::::::::

::::::::::::::::::::::::::::::::::::::::::::::::::

:::::::::::::::::::::::::::::::::::::::::::: виклик

## Прибрати цей код

1. Прочитайте цю коротку програму і спробуйте передбачити, що вона робить.
2. Запустити її: наскільки точним був ваш прогноз?
3. Розв'язати програму, щоб зробити її більш читабельною.
   Не забувайте запускати його після кожної зміни, щоб гарантувати його поведінку не змінилася.
4. Порівняйте свій перезапис з сусідами.
   Що ти зробила так само?
   Що ви робите по-іншому, і чому?

```python
n = 10
s = 'et cetera'
print(s)
i = 0
while i < n:
    # print('at', j)
    new = ''
    for j in range(len(s)):
        left = j-1
        right = (j+1)%len(s)
        if s[left]==s[right]: new = new + '-'
        else: new = new + '*'
    s=''.join(new)
    print(s)
    i += 1
```

:::::::::::::::::::: Рішення

## Розв'язок

Ось одне рішення.

```python
def string_machine(input_string, iterations):
    """
    Takes input_string and generates a new string with -'s and *'s
    corresponding to characters that have identical adjacent characters
    or not, respectively.  Iterates through this procedure with the resultant
    strings for the supplied number of iterations.
    """
    print(input_string)
    input_string_length = len(input_string)
    old = input_string
    for i in range(iterations):
        new = ''
        # iterate through characters in previous string
        for j in range(input_string_length):
            left = j-1
            right = (j+1) % input_string_length  # ensure right index wraps around
            if old[left] == old[right]:
                new = new + '-'
            else:
                new = new + '*'
        print(new)
        # store new string as old
        old = new     

string_machine('et cetera', 10)
```

```output
et cetera
*****-***
----*-*--
---*---*-
--*-*-*-*
**-------
***-----*
--**---**
*****-***
----*-*--
---*---*-
```

:::::::::::::::::::::::::

::::::::::::::::::::::::::::::::::::::::::::::::::

:::::::::::::::::::::::::::::::::::::::: keypoints

- Виконайте стандартний стиль Python в коді.
- Використовуйте док-струни, щоб надати вбудовану допомогу.

::::::::::::::::::::::::::::::::::::::::::::::::::
